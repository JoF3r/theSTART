{"config":{"lang":["en","pt"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"~$ whoami","text":"<p>Jo\u00e3o \u2013 tech enthusiast, breaker of things, occasional fixer </p> <p>Hey, my name is Jo\u00e3o and I\u2019m a tech enthusiast who loves breaking things, not always fixing them, and sometimes learning along the way. I\u2019m currently a student, so between classes and life, I try to spend time diving into cybersecurity, playing CTFs, pwning machines on TryHackMe and HackTheBox, and tinkering with electronics.  </p> <p>This repo is basically my personal brain dump, where I document my projects, things I\u2019m learning, and random experiments.  </p> <p>\ud83d\udea7 Still a work in progress... updates will come whenever I get around to it! \ud83d\ude06  </p> <p>Dark mode next to the search bar :)</p>"},{"location":"#find-me-here","title":"\ud83d\udcec Find me here:","text":""},{"location":"HOW_IT_WORKS/","title":"Pwnagotchi: How it Works","text":"<p>Pwnagotchi is an A2C-based (\u201cAI\u201d) powered by bettercap that learns from its surrounding WiFi environment in order to maximize the crackable WPA key material it captures (either through passive sniffing or by performing deauthentication and association attacks). This material is collected on disk as PCAP files containing any form of crackable handshake supported by hashcat, including full and half WPA handshakes as well as PMKIDs.</p>"},{"location":"HOW_IT_WORKS/#key-terms","title":"Key Terms","text":"<ul> <li> <p>A2C: This stands for Advantage Actor-Critic, which is an algorithm used in reinforcement learning. It combines both the actor (which decides what action to take) and the critic (which evaluates the action taken). A2C is used in the Pwnagotchi\u2019s AI to help it adapt and improve its actions over time, based on the feedback from its environment.</p> </li> <li> <p>Bettercap: This is a tool used for network attacks and packet manipulation, which allows Pwnagotchi to interact with wireless networks and gather data for Wi-Fi cracking.</p> </li> <li> <p>Deauthentication and Association Attacks: These are types of attacks used to disrupt the connection between a device and a Wi-Fi network. Deauthentication causes a device to disconnect from a network, and Association attacks allow Pwnagotchi to intercept the process and capture handshakes.</p> </li> <li> <p>PCAP files: These are files used to store network traffic data, specifically Wi-Fi handshakes (critical for cracking WPA keys). Pwnagotchi collects these for later hashcat processing.</p> </li> <li> <p>Handshakes: These are pieces of data exchanged between a Wi-Fi client and an access point during the connection process. They are essential for cracking WPA keys.</p> </li> <li> <p>Hashcat: A password cracking tool used to crack encrypted data like WPA handshakes. It can use various techniques to try and break the encryption.</p> </li> <li> <p>PMKID: This is a specific type of data that can also be used to crack WPA encryption. PMKID is a Pre-Shared Key identifier used in WPA2 networks and is often targeted in Wi-Fi hacking.</p> </li> </ul>"},{"location":"HOW_IT_WORKS/#how-does-pwnagotchi-work","title":"How does Pwnagotchi work?","text":"<p>Instead of merely playing Super Mario or Atari games like most reinforcement learning-based AI (yawn), Pwnagotchi tunes its own parameters over time to get better at pwning WiFi things in the environments you expose it to.</p> <p>To be more precise, Pwnagotchi is using an LSTM with an MLP feature extractor as its policy network for the A2C agent. If you\u2019re unfamiliar with A2C, here is a very good introductory explanation (in comic form!) of the basic principles behind how Pwnagotchi learns. Be sure to check out the Usage doc for more pragmatic details of how to help your Pwnagotchi learn as quickly as possible.</p> <ul> <li> <p>LSTM (Long Short-Term Memory): A type of recurrent neural network (RNN) used in machine learning. LSTM networks are great for learning from sequences of data (like Wi-Fi networks over time) because they can \"remember\" past events and adjust their actions accordingly.</p> </li> <li> <p>MLP (Multilayer Perceptron): A type of neural network used for feature extraction, which helps the system analyze and process data more effectively. Pwnagotchi uses it to process information from the Wi-Fi environment and make better decisions.</p> </li> </ul> <p>Unlike the usual reinforcement learning simulations, Pwnagotchi actually learns at a human timescale because it is interacting with a real-world environment instead of a well-defined virtual environment (like playing Super Mario). Time for a Pwnagotchi is measured in epochs; a single epoch can last anywhere from a few seconds to many minutes, depending on how many access points and client stations are visible.</p> <ul> <li>Epoch: In machine learning, an epoch refers to one complete cycle through the entire dataset. For Pwnagotchi, this means a cycle of interaction with Wi-Fi networks.</li> </ul> <p>Do not expect your Pwnagotchi to perform amazingly well at the very beginning, as it will be exploring several combinations of key parameters to determine ideal adjustments for pwning the particular environment you are exposing it to during its beginning epochs ... but definitely listen to your Pwnagotchi when it tells you it's bored! Bring it into novel WiFi environments with you and have it observe new networks and capture new handshakes\u2014and you'll see. :)</p>"},{"location":"HOW_IT_WORKS/#multi-unit-interaction","title":"Multi-Unit Interaction","text":"<p>Multiple units within close physical proximity can \u201ctalk\u201d to each other, advertising their own presence to each other by broadcasting custom information elements using a parasite protocol I\u2019ve built on top of the existing dot11 standard. Over time, two or more Pwnagotchi units trained together will learn to cooperate upon detecting each other\u2019s presence by dividing the available channels among them for optimal pwnage.</p> <ul> <li> <p>Parasite protocol: A custom protocol developed to allow multiple Pwnagotchi devices to communicate with each other, sharing information about their surrounding networks and synchronizing their activities for more efficient Wi-Fi cracking.</p> </li> <li> <p>dot11 standard: Refers to the IEEE 802.11 standard, which defines the protocols for wireless networking, like Wi-Fi. This is the foundation for how Pwnagotchi interacts with Wi-Fi networks.</p> </li> </ul>"},{"location":"HOW_IT_WORKS/#moods-and-states","title":"Moods and States","text":"<p>Depending on the status of the unit, several states and state transitions are configurable and represented on the display as different moods, expressions, and sentences. Pwnagotchi speaks many languages, too!</p> <ul> <li>Moods: The \"mood\" refers to the way Pwnagotchi expresses its internal state visually and verbally. Moods can change based on how well it is performing or how \"bored\" it is with the environment.</li> </ul> <p>Of course, it IS possible to run your Pwnagotchi with the AI disabled (configurable in <code>config.toml</code>). Why might you want to do this? Perhaps you simply want to use your own fixed parameters (instead of letting the AI decide for you), or maybe you want to save battery and CPU cycles, or maybe it\u2019s just you have strong concerns about aiding and abetting baby Skynet. Whatever your particular reasons may be: an AI-disabled Pwnagotchi is still a simple and very effective automated deauther, WPA handshake sniffer, and portable bettercap + webui dedicated hardware.</p> <ul> <li> <p>Deauther: A tool that performs deauthentication attacks, disrupting Wi-Fi connections and enabling the capture of handshakes for WPA cracking.</p> </li> <li> <p>WebUI: A web user interface that allows you to interact with Pwnagotchi through a browser for easier management and monitoring.</p> </li> </ul>"},{"location":"Password%20Manager/","title":"Self-Hosting Vaultwarden on Raspberry Pi Zero 2","text":""},{"location":"Password%20Manager/#why","title":"Why?","text":"<p>Many people use simple or reused passwords for online services because they are easier to remember. While I used to do the same, I realized that storing passwords in web browsers is neither secure nor advisable.</p> <p>To improve my security, I decided to set up a self-hosted password manager using Vaultwarden. </p> <p>Vaultwarden is a lightweight, self-hosted alternative to Bitwarden. It provides the same functionality while being optimized for low-resource devices like the Raspberry Pi Zero 2 W. It also offers features like Multi-Factor Authentication (MFA), backups, SSL encryption, and remote access, ensuring better security while giving me full control over my credentials.</p> <p>To achieve this, I used the following hardware:</p> <ul> <li>Raspberry Pi Zero 2 W, compact and low-power makes it ideal for self-hosted applications.</li> <li>Waveshare 2.13 inch e-paper HAT v4</li> <li>MicroSD card with 32Gb</li> <li>Card reader</li> <li>Windows PC</li> </ul>"},{"location":"Password%20Manager/#flash-raspberry-pi-os-lite-64-bit","title":"Flash Raspberry Pi OS Lite (64-bit)","text":"<p>The first step was to flash Raspberry Pi OS Lite (64-bit) onto the microSD card. I used the Raspberry Pi Imager tool to complete this process.</p> <ol> <li>Insert the microSD card into the card reader.</li> <li>Open Raspberry Pi Imager and Choose OS &gt; Raspberry Pi OS (Other) &gt; Raspberry Pi OS Lite (64-bit).</li> <li>Choose the microSD card as the storage device.</li> <li>Click Next, then Edit Settings to configure:  Enable Set hostname, set up a username and password, Configure Wireless LAN and  Enable SSH to allow remote access.</li> </ol> <p>Enabling SSH allows remote access and control over the Raspberry Pi from another device. Since the Raspberry Pi Zero 2 W often runs headless (without a monitor or keyboard), SSH provides a convenient way to configure and manage the system over the network.</p> <ol> <li>Save and click Yes to use the settings, then wait to write.</li> </ol>"},{"location":"Password%20Manager/#connect-over-ssh","title":"Connect Over SSH","text":"<p>Since SSH was enabled at the time of writing the OS, I can now connect to the Raspberry Pi over SSH using PuTTY:</p> <ol> <li>Insert the microSD card into the Raspberry Pi and power it on.</li> <li>Open PuTTY on my Windows PC.</li> <li>Enter the Raspberry Pi's IP address (found via nmap) in the Host Name (or IP address) field.</li> <li>Ensure the Port is set to <code>22</code> and Connection type is SSH.</li> <li>Click Open to initiate the connection.</li> <li>When prompted, enter the username and password set during configuration.</li> </ol>"},{"location":"Password%20Manager/#on-the-terminal","title":"On the terminal","text":"<p>To make sure everything runs smoothly, I started by updating and upgrading the software packages:</p> <pre><code>sudo apt update &amp;&amp; sudo apt full-upgrade -y\n</code></pre>"},{"location":"Password%20Manager/#install-docker-and-portainer","title":"Install Docker and Portainer","text":"<ol> <li>Install Docker: <code>curl -sSL https://get.docker.com | sh</code></li> <li>Grant Docker permissions to my user (joaof): <code>sudo usermod -aG docker joaof</code></li> <li>Rebooted the system for changes to take effect.: <code>sudo reboot</code></li> <li>Although Docker containers can be managed via the command line, Portainer provides a user-friendly GUI interface for deploying and managing our Docker containers on Raspberry Pi. To pull the latest version of Portainer from Docker Hub: <code>sudo docker pull portainer/portainer-ce:latest</code></li> <li>Creating and running a Portainer container. This command exposes the Portainer web interface on port 9000 and ensures Portainer is always restarted if the system reboots.</li> </ol> <pre><code>sudo docker run -d -p 9000:9000 --restart=always --name=portainer -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer-ce:latest\n</code></pre> <ol> <li>With the container running, opened then web browser and accessed the Portainer UI with: <code>http://192.168.1.228:9000</code>.</li> </ol>"},{"location":"Password%20Manager/#install-and-set-up-vaultwarden-rs-vaultwarden","title":"Install and Set Up Vaultwarden RS (Vaultwarden)","text":"<p>After creating a Portainer account, I'll deploy and set up a self-hosted Vaultwarden server on the Pi.</p> <ol> <li>Click on Volume &gt; Add Volume</li> <li>Created a volume named VaultwardenServer</li> <li>Containers &gt; Add Container and did the following:<ul> <li>Name: Vaultwarden</li> <li>Image: vaultwarden/server:1.32.0 (latest was not working) </li> <li>Map an additional port, forwarding 8080 on the host to 80 in the container.  This allows any device on the local network to access the Vaultwarden server via http://192.168.1.228:8080.</li> <li>Volumes &gt; Map additional volume with <code>/data</code> in the container field and the <code>VaultwardenServer</code>volume created before</li> <li>Under Restart Policy selected <code>Always</code></li> <li>Finally, click Deploy the container and after a few minutes,  the Vaultwarden server is displayed as healthy in the Portainer UI</li> </ul> </li> <li>I can now visit <code>http://192.168.1.228:8080</code> Which opens the Vaultwarden web UI.</li> </ol>"},{"location":"Password%20Manager/#set-up-the-reverse-proxy","title":"Set Up the reverse proxy","text":"<p>To access and use Vaultwarden, I need to set up a reverse proxy. For this I'll be using Nginx Proxy Manager.</p> <ol> <li>Ran the following command to pull the latest nginx image and start the container:</li> </ol> <pre><code>sudo docker run -d \\\n  --name=nginx-proxy-manager \\\n  -p 81:81 \\\n  -p 80:80 \\\n  -p 443:443 \\\n  -v /srv/dev-disk-by-label-Backup/Docker/nginx-proxy-manager/data:/data \\\n  -v /srv/dev-disk-by-label-Backup/Docker/nginx-proxy-manager/letsencrypt:/etc/letsencrypt \\\n  --restart unless-stopped \\\n  jc21/nginx-proxy-manager:latest\n</code></pre> <ol> <li> <p>To check if the container starts successfully, I opened Portainer  and verified that the <code>nginx-proxy-manager</code> container was running.  Another way would be to run:  <code>docker ps -a</code>. If the container wasn\u2019t running, For troubleshooting:  <code>docker logs nginx-proxy-manager</code>.</p> </li> <li> <p>With the container up I can access the Nginx Proxy Manager web UI at  <code>http://192.168.1.228:81</code>.</p> </li> </ol>"},{"location":"Password%20Manager/#securing-vaultwarden-with-https-using-lets-encrypt-duckdns","title":"Securing Vaultwarden with HTTPS Using Let\u2019s Encrypt &amp; DuckDNS","text":"<p>Now that the reverse proxy is set up, I need to secure access  to Vaultwarden with HTTPS. I'll use DuckDNS for dynamic DNS,   and Let\u2019s Encrypt to generate a free SSL certificate.  </p> <p>This will allow me to access Vaultwarden securely from anywhere  without relying on a static IP or a paid domain.</p>"},{"location":"Password%20Manager/#set-up-duckdns","title":"Set Up DuckDNS","text":"<ol> <li>Visited DuckDNS and created an account.  </li> <li>Added a new subdomain chaveman.duckdns.org and  linked it to my IPv4 address.  </li> <li>Copied my DuckDNS Token from the page (I'll need it later).</li> </ol>"},{"location":"Password%20Manager/#generate-an-ssl-certificate-using-lets-encrypt","title":"Generate an SSL Certificate Using Let's Encrypt","text":"<ol> <li>Used Certbot with the DNS-01 challenge to obtain an SSL certificate  for my DuckDNS domain: Ran the following command to request a certificate using the DNS-01 challenge:  </li> </ol> <pre><code>sudo apt update &amp;&amp; sudo apt install certbot -y\nsudo certbot certonly --manual --preferred-challenges dns -d chaveman.duckdns.org\n</code></pre> <ol> <li>Certbot provided a TXT record that needs to be added to DNS for verification. Using DuckDNS's update URL: <code>https://www.duckdns.org/update?domains=chaveman&amp;token=MY_TOKEN&amp;txt=TXTVALUE&amp;verbose=true</code> i got an OK and this means DuckDNS set my TXT record.</li> <li>To make sure that the TXT Record was Published waited a couple of minutes for DNS to propagate and using Google Admin Toolbox (Dig) I could see my  TXT Value value under the ANSWER section so we're good to go.</li> <li>Pressed Enter and Certbot created two cert files <code>fullchain.pem</code> and <code>privkey.pem</code> in <code>/etc/letsencrypt/live/Vaultwarden.duckdns.org/</code>.</li> <li><code>sudo certbot certificates</code> to check the certificates expirity date,  was 90 days so to make it automaticaly renew: <code>sudo crontab -e</code> to open the crontab file with NANO and added the cron job <code>0 0 * * * certbot renew --quiet</code> which will run Certbot command to renew the SSL certificates automatically, ensuring the website's encryption remains valid without manual intervention.</li> </ol>"},{"location":"Password%20Manager/#nginx-proxy-manager","title":"Nginx Proxy Manager","text":"<p>Since the Web UI\u2019s file explorer only shows local files, I had to copy the cert files from the Raspberry Pi to my local machine so they could be uploaded.</p> <ol> <li>Copy the cert files to my local machine using <code>scp</code> (secure copy):</li> </ol> <pre><code>  scp joaof@192.168.1.228:/etc/letsencrypt/live/Vaultwarden.duckdns.org/fullchain.pem /home/joaof/Documents/Certificates\n  scp joaof@192.168.1.228:/etc/letsencrypt/live/Vaultwarden.duckdns.org/privkey.pem /home/joaof/Documents/Certificates\n</code></pre> <ol> <li>Returned to the Nginx Proxy Manager Web UI &gt; SSL Certificates &gt;  Add SSL Certificate &gt; Custom and selected the cert files:</li> <li>Add Proxy Host: </li> <li>Under SSL: </li> </ol> <p>At this point I should've been able to connect to https://chaveman.duckdns.org but i was getting an SSL error on the browser and using Port Checker I can see that my ISP is blocking inbound traffic for port 443.</p> <ol> <li>Access my router configurations to port forward the 443 port to the rpi.</li> <li>Finally connect to https://chaveman.duckdns.org and access Vaultwarden.</li> </ol>"},{"location":"Password%20Manager/#enhancing-vaultwarden-with-an-e-paper-display","title":"Enhancing Vaultwarden with an E-Paper Display","text":"<ol> <li>Enabled SPI on my Raspberry Pi by running: <code>sudo raspi-config</code></li> <li>Navigated to Interfacing Options &gt; SPI &gt; Enable</li> <li>After enabling SPI, I rebooted the system: <code>sudo reboot</code></li> <li>Installing the necessary Python libraries:</li> </ol> <pre><code>sudo apt-get update\nsudo apt-get install python3-pip python3-pil python3-numpy\nsudo apt-get install python3-spidev python3-rpi.gpio\nsudo apt-get install python3-psutil\n</code></pre> <ol> <li>Cloned the waveshareteam repo and moved into the correct directory: </li> </ol> <pre><code>git clone https://github.com/waveshare/e-Paper.git\ncd ~/e-Paper/RaspberryPi_JetsonNano/python\n</code></pre> <ol> <li>For the Waveshare 2.13-inch v4 display, I used the <code>epd2in13_V4</code> module from <code>../lib/waveshare_epd</code> and tested it using <code>../examples/epd2in13_V4_test.py</code>. From there, I built system_monitor_v1 to display system info like temperature, uptime, and IP address.</li> </ol> <p>outra possibilidade seria obter um dominio e cloudflare tunnel</p>"},{"location":"PwnZilla%20Guia/","title":"PwnZilla","text":""},{"location":"PwnZilla%20Guia/#overview","title":"\ud83d\udccc Overview","text":"<p>This project documents my journey of setting up and customizing a Pwnagotchi from scratch.</p> <p>The Pwnagotchi is an A2C-based \u201cAI\u201d powered by Bettercap. It learns from its surrounding WiFi environment to maximize the collection of crackable WPA key material. This can include material captured via passive sniffing or through deauthentication and association attacks.</p> <p>Originally created by EvilSocket, the project wasn't actively maintained for a while, but it was later picked up and continued by Jayofelony. For more up-to-date information, you can refer to both the new website and the original one.</p> <p>I\u2019ll be using Jayofelony's image (v2.8.9), 64-bit, as I\u2019m working with a Raspberry Pi Zero 2 W. If you\u2019re using different hardware, you can check the available images and choose the one that matches your setup.</p> <p>I\u2019ve chosen to use jayofelony\u2019s v2.8.9 image because the AI feature was removed in the later release.</p> <p>For this setup, I\u2019ll be using Windows as my main operating system, along with PuTTY for SSH access and 7-Zip to extract the image file. Additionally, I\u2019ll need RNDIS drivers, which can be downloaded from ModCloud here</p> <p>If you\u2019re looking for a deeper explanation of how the Pwnagotchi works, feel free to check out in depth info.</p> <p> </p>"},{"location":"PwnZilla%20Guia/#hardware","title":"Hardware","text":"<ul> <li>Raspberry Pi Zero 2W with headers </li> <li>MicroSD Card 32Gb but 8Gb would be enough </li> <li>Waveshare v4 2.13Inch e-Paper HAT</li> <li>Micro USB Data+Power Raspberry Pi cable  </li> <li>Power bank  </li> </ul>"},{"location":"PwnZilla%20Guia/#installation-flashing","title":"Installation &amp; Flashing","text":"<ol> <li>Downloaded v2.8.9 from jayofelony's repo</li> <li>Flashing the image using the Raspberry Pi Imager</li> </ol>"},{"location":"PwnZilla%20Guia/#configurations","title":"Configurations","text":""},{"location":"pt/","title":"~$ whoami","text":"<p>Jo\u00e3o \u2013 tech enthusiast, breaker of things, occasional fixer </p> <p>Hey, my name is Jo\u00e3o and I\u2019m a tech enthusiast who loves breaking things, not always fixing them, and sometimes learning along the way. I\u2019m currently a student, so between classes and life, I try to spend time diving into cybersecurity, playing CTFs, pwning machines on TryHackMe and HackTheBox, and tinkering with electronics.  </p> <p>This repo is basically my personal brain dump, where I document my projects, things I\u2019m learning, and random experiments.  </p> <p>\ud83d\udea7 Still a work in progress... updates will come whenever I get around to it! \ud83d\ude06  </p>"},{"location":"pt/Password%20Manager/#step-1-flash-raspberry-pi-os-lite-64-bit","title":"Step 1: Flash Raspberry Pi OS Lite (64-bit)","text":"<p>The first step was to flash Raspberry Pi OS Lite (64-bit) onto the microSD card. I used the Raspberry Pi Imager tool to complete this process.</p> <ol> <li>Insert the microSD card into the card reader.</li> <li>Open Raspberry Pi Imager and Choose OS &gt; Raspberry Pi OS (Other) &gt; Raspberry Pi OS Lite (64-bit).</li> <li>Choose the microSD card as the storage device.</li> <li>Click Next, then Edit Settings to configure:  Enable Set hostname, set up a username and password, Configure Wireless LAN and  Enable SSH to allow remote access.</li> </ol> <p>Enabling SSH allows remote access and control over the Raspberry Pi from another device. Since the Raspberry Pi Zero 2 W often runs headless (without a monitor or keyboard), SSH provides a convenient way to configure and manage the system over the network.</p> <ol> <li>Save and click Yes to use the settings, then wait to write.</li> </ol>"},{"location":"pt/Password%20Manager/#step-2-connect-over-ssh","title":"Step 2: Connect Over SSH","text":"<p>Since SSH was enabled at the time of writing the OS, I can now connect to the Raspberry Pi over SSH using PuTTY:</p> <ol> <li>Insert the microSD card into the Raspberry Pi and power it on.</li> <li>Open PuTTY on my Windows PC.</li> <li>Enter the Raspberry Pi's IP address (found via nmap) in the Host Name (or IP address) field.</li> <li>Ensure the Port is set to <code>22</code> and Connection type is SSH.</li> <li>Click Open to initiate the connection.</li> <li>When prompted, enter the username and password set during configuration.</li> </ol>"},{"location":"pt/Password%20Manager/#step-3-on-the-terminal","title":"Step 3: On the terminal","text":"<p>To make sure everything runs smoothly, I started by updating and upgrading the software packages:</p> <pre><code>sudo apt update &amp;&amp; sudo apt full-upgrade -y\n</code></pre>"}]}